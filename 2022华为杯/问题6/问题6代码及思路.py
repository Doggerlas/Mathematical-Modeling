# -*- coding: utf-8 -*-
"""问题6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hkSB3vWrrdi-2k_Har1wAV8zHwEOXzeC
"""

! pip install matplotlib 
! pip install mplfonts

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import warnings 
from sklearn.metrics import r2_score
warnings.filterwarnings('ignore')
# %matplotlib inline
import numpy as np
from sklearn.preprocessing import MinMaxScaler
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import LSTM
from keras.models import Sequential, load_model
np.set_printoptions(suppress=True)

import matplotlib.pyplot as plt
from mplfonts.bin.cli import init
init()
from mplfonts import use_font
use_font('Noto Serif CJK SC')#指定中文字体

from sklearn.preprocessing import MinMaxScaler
from pylab import *
plt.rcParams['font.sans-serif'] = ['SimHei']
plt.rcParams['axes.unicode_minus'] = False 
import seaborn as sns 
sns.set_palette("husl") #设置所有图的颜色，使用hls色彩空间
import numpy as np
from sklearn import metrics
from sklearn.metrics import mean_squared_error #均方误差
from sklearn.metrics import mean_absolute_error #平方绝对误差

q4_res=pd.read_excel('MGIG8.xlsx')#需要更改为三个文件遍历
q4_res

#选择区域
Block='G8'#按文件名一致

# 选出某个小区(如G21)月份是9月份 的所有数据
gBlock_9=q4_res[(q4_res['放牧小区（plot）']==Block ) & (q4_res['月份']==9 )]
gBlock_9.reset_index(inplace=True,drop=True)
gBlock_9=gBlock_9.groupby('年份').mean()# 按年份合并，每一年的数值为均值
gBlock_9.reset_index(inplace=True,drop=False)
gBlock_9

# G21 5年的土壤湿度和有机物含量相对关系
wet=gBlock_9['土壤湿度'].values
org=gBlock_9['有机物含量'].values
year=[2012,2014,2016,2018,2020]

fig,ax=plt.subplots()
ax.scatter(wet,org,c='r')

for i,txt in enumerate(year):
    ax.annotate(txt,(wet[i],org[i]))

plt.axhline(y=org.mean(),ls="-")
plt.axvline(x=wet.mean(),ls="-")
plt.legend()
#plt.xlabel('土壤湿度')
#plt.ylabel('有机物含量')
plt.xlabel('Earth_Wet')
plt.ylabel('Organic')
s='2012~2020 Mon_9 '+Block+' Earth_Status'
plt.title (s)
plt.savefig(s+'.png')

dataset=gBlock_9[['土壤湿度', '有机物含量']]
dataset

#########LSTM多变量模型#############
def split_sequences(sequences, n_steps):
    X, y = list(), list()
    for i in range(len(sequences)):
        end_ix = i + n_steps
        if end_ix > len(sequences)-1:
            break
        # 最关键的不一样在这一步
        seq_x, seq_y = sequences[i:end_ix, :], sequences[end_ix, :]
        X.append(seq_x)
        y.append(seq_y)
    return np.array(X), np.array(y)
def mean_absolute_percentage_error(y_true, y_pred): 

    return np.mean(np.abs((y_true - y_pred) / y_true)) * 100

def fitlstmmodel(dataset,n_steps=1):
    #dataset：数据标准化后的dataset
    # n_steps：分片大小，默认为1
    #依次为：'PM2.5','AQI',  'PM10', 'SO2', 'CO', 'NO2', 'O3_8h', '最高气温', '最低气温'

    in_seq1= dataset[:,0].reshape((dataset.shape[0], 1))
    in_seq2= dataset[:,1].reshape((dataset.shape[0], 1))

    dataset = np.hstack((in_seq1, in_seq2))
    X, y = split_sequences(dataset, n_steps)
    n_features = X.shape[2]#2
    model = Sequential()
    model.add(LSTM(300, activation='relu', return_sequences=True, input_shape=(n_steps, n_features)))
    model.add(LSTM(300, activation='relu'))

    # 和多对一不同点在于，这里多对多的Dense的神经元=features数目
    model.add(Dense(n_features))
    model.compile(optimizer='adam', loss='mse')
    model.fit(X, y, epochs=100, verbose=2,shuffle=False)
    model.save('lstm_model.h5')
    last_input=np.array(dataset[-1:,:])
    return X,y,last_input,n_features,n_steps
# 将整型变为float
dataset = dataset.astype('float32')
#对数据集合进行标准化
scaler = MinMaxScaler(feature_range=(0, 1))

dataset=scaler.fit_transform(dataset)
#输入为标准化后的dataset 	#输出：X为lstm的输入，y为lstm的输出，x_input_last为最后一行dataset的数据，用于预测未来的输入,n_features是特征维度，n_steps是切片分层
X,y,last_input,n_features,n_steps=fitlstmmodel(dataset,n_steps=1)

###预测与评分
#输入1为lstm的输入X，输入2为lstm的输出y，用于训练模型,输入3为标准化模型
#输出：testPredict为预测close的训练数据，testY为close的真实数据
#该函数目标输出训练的RMSE以及预测与训练数据的对比
def Predict_RMSE_BA(X,y,scaler):
    model=load_model('lstm_model.h5') 
    trainPredict = model.predict(X)
    testPredict = scaler.inverse_transform(trainPredict)
    testY = scaler.inverse_transform(y)
    score(testY[:,0], testPredict[:,0])
    
    #土壤湿度', '有机物含量'
    plt.plot(testY[:,0],color='blue', label='observed data')
    plt.plot(testPredict[:,0], color='red', label='LSTM')
    plt.xlabel('year')
    plt.ylabel('Earth_Wet')
    s='2012~2020 Mon_9 '+Block+' Earth_Wet'
    plt.title (s)
    plt.savefig(s+'.jpg')
    plt.show()

    
    score(testY[:,1], testPredict[:,1])
    plt.plot(testY[:,1],color='blue', label='observed data')
    plt.plot(testPredict[:,1], color='red', label='LSTM')
    plt.xlabel('year')
    plt.ylabel('Organic')
    s='2012~2020 Mon_9 '+Block+' Organic'
    plt.title (s)
    plt.legend()
    plt.savefig(s+'.jpg')
    plt.show()
    return testPredict,testY
def score(y_true, y_pre):
    # MSE
    print("MAPE :")
    print(mean_absolute_percentage_error(y_true, y_pre)) 
    # RMSE
    print("RMSE :")
    print(np.sqrt(metrics.mean_squared_error(y_true, y_pre))) 
    # MAE
    print("MAE :")
    print(metrics.mean_absolute_error(y_true, y_pre)) 
    # # R2
    # print("R2 :")
    # print(np.abs(r2_score(y_true,y_pre)))
testPredict,testY=Predict_RMSE_BA(X,y,scaler)

def Predict_future_plot(predict_forword_number,x_input,n_features,n_steps,scaler,testPredict,testY):
    model=load_model('lstm_model.h5') 
    predict_list=[]
    predict_list.append(x_input)
    while len(predict_list) < predict_forword_number:

        x_input = predict_list[-1].reshape((-1, n_steps, n_features))
        yhat = model.predict(x_input, verbose=0)
         #预测新值
        predict_list.append(yhat)
    #取出    
    
    Predict_forword = scaler.inverse_transform(np.array([ i.reshape(-1,1)[:,0].tolist() for i in predict_list]))
    return Predict_forword[1:,:].tolist()

y_pre=Predict_future_plot(2,last_input,n_features,n_steps,scaler,testPredict,testY)
y_pre

# G21 5年的土壤湿度和有机物含量相对关系
wet=gBlock_9['土壤湿度'].values
org=gBlock_9['有机物含量'].values
wet=np.append(wet,y_pre[0][0])
org=np.append(org,y_pre[0][1])
year=[2012,2014,2016,2018,2020,2023]

fig,ax=plt.subplots()
ax.scatter(wet,org,c='r')

for i,txt in enumerate(year):
    ax.annotate(txt,(wet[i],org[i]))

plt.axhline(y=org.mean(),ls="-")
plt.axvline(x=wet.mean(),ls="-")
plt.legend()
#plt.xlabel('土壤湿度')
#plt.ylabel('有机物含量')
plt.xlabel('Earth_Wet')
plt.ylabel('Organic')
s='2012~2023 Mon_9 '+Block+' Earth_Status'
plt.title (s)
plt.savefig(s+'.jpg')